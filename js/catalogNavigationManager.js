/**
 * ============================================================
 * CATALOG NAVIGATION MANAGER
 * ============================================================
 * 
 * Gerencia navega√ß√£o incremental atrav√©s do cat√°logo de 811 soundfonts
 * usando mensagens MIDI Program Change (0-127) como comandos de rolagem.
 * 
 * Funcionalidade:
 * - Interpreta Program Change como incremento (+1) ou decremento (-1)
 * - Navega√ß√£o circular: 811 ‚Üí 1 e 1 ‚Üí 811
 * - Suporta todos os canais MIDI (0-15)
 * - Atualiza interface visual automaticamente
 * - Dispara som do soundfont selecionado
 * 
 * @version 1.0.0
 * @date 2025-10-17
 */

class CatalogNavigationManager {
    constructor(catalogManager, soundfontManager) {
        this.catalogManager = catalogManager;
        this.soundfontManager = soundfontManager;
        
        // Estado de navega√ß√£o
        this.currentIndex = 1; // √çndice atual no cat√°logo (1-811)
        this.totalSoundfonts = 0; // Total de soundfonts dispon√≠veis
        this.flatCatalog = []; // Cat√°logo linearizado para acesso por √≠ndice
        
        // Estado de Program Change por canal
        this.channelState = new Map(); // Map<channel, lastProgramValue>
        
        // Refer√™ncia ao seletor de instrumentos
        this.instrumentSelectorControls = null; // Ser√° definido via setInstrumentSelectorControls()
        
        // Inicializar canais MIDI (0-15)
        for (let channel = 0; channel < 16; channel++) {
            this.channelState.set(channel, null);
        }
        
        // Callbacks
        this.onIndexChange = null; // Callback(index, soundfont)
        this.onSoundfontLoad = null; // Callback(soundfont, index)
        
        // Inicializar cat√°logo plano
        this.initializeFlatCatalog();
        
        console.log('üéº CatalogNavigationManager inicializado');
        console.log(`   ‚îú‚îÄ Total de soundfonts: ${this.totalSoundfonts}`);
        console.log(`   ‚îú‚îÄ √çndice inicial: ${this.currentIndex}`);
        console.log(`   ‚îú‚îÄ Navega√ß√£o circular: habilitada`);
        console.log(`   ‚îî‚îÄ ‚ö†Ô∏è instrumentSelectorControls ainda N√ÉO conectado (esperando app.js)`);
        
        // Timer de verifica√ß√£o de inicializa√ß√£o (aumento para 3 segundos para dar mais tempo)
        setTimeout(() => {
            if (!this.instrumentSelectorControls) {
                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.error('‚ùå ERRO DE INICIALIZA√á√ÉO CR√çTICO');
                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.error('‚ö†Ô∏è instrumentSelectorControls N√ÉO foi conectado ap√≥s 3 segundos!');
                console.error('');
                console.error('Fluxo esperado em app.js:');
                console.error('1. window.instrumentSelector.setupInstrumentSelection() ‚Üí retorna controls');
                console.error('2. window.catalogNavigationManager.setInstrumentSelectorControls(controls)');
                console.error('');
                console.error('Estado atual:');
                console.error('- window.instrumentSelector:', typeof window.instrumentSelector);
                console.error('- window.setupInstrumentSelection:', typeof window.setupInstrumentSelection);
                console.error('- window.instrumentSelectorControls:', window.instrumentSelectorControls);
                console.error('- document.getElementById("instrument-grid"):', document.getElementById('instrument-grid'));
                console.error('');
                console.error('Verifique:');
                console.error('- Se o elemento #instrument-grid existe no HTML');
                console.error('- Se os scripts est√£o carregando na ordem correta');
                console.error('- Se setupInstrumentSelection() est√° retornando null/undefined');
                console.error('- Console para erros anteriores (role para cima)');
                console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            } else {
                console.log('‚úÖ Verifica√ß√£o de inicializa√ß√£o: instrumentSelectorControls conectado com sucesso!');
            }
        }, 3000);
    }
    
    /**
     * Define refer√™ncia aos controles do seletor de instrumentos
     * @param {Object} controls - Objeto retornado por setupInstrumentSelection()
     */
    setInstrumentSelectorControls(controls) {
        if (!controls) {
            console.error('‚ùå setInstrumentSelectorControls: controls √© null ou undefined');
            return;
        }
        
        // Validar m√©todos essenciais
        const requiredMethods = ['selectInstrumentByIndex', 'navigateByDirection', 'getTotalInstruments'];
        const missingMethods = requiredMethods.filter(method => typeof controls[method] !== 'function');
        
        if (missingMethods.length > 0) {
            console.error(`‚ùå Controles do seletor inv√°lidos. M√©todos ausentes: ${missingMethods.join(', ')}`);
            console.error('   Objeto recebido:', controls);
            console.error('   M√©todos dispon√≠veis:', Object.keys(controls).filter(k => typeof controls[k] === 'function'));
            return;
        }
        
        this.instrumentSelectorControls = controls;
        console.log('‚úÖ CatalogNavigationManager conectado ao InstrumentSelector');
        console.log(`   ‚îú‚îÄ Total de instrumentos no seletor: ${controls.getTotalInstruments()}`);
        console.log(`   ‚îú‚îÄ M√©todos dispon√≠veis:`);
        console.log(`   ‚îÇ  ‚îú‚îÄ selectInstrumentByIndex: ‚úÖ`);
        console.log(`   ‚îÇ  ‚îú‚îÄ navigateByDirection: ‚úÖ`);
        console.log(`   ‚îÇ  ‚îú‚îÄ triggerSpinUp: ${typeof controls.triggerSpinUp === 'function' ? '‚úÖ' : '‚ùå'}`);
        console.log(`   ‚îÇ  ‚îî‚îÄ triggerSpinDown: ${typeof controls.triggerSpinDown === 'function' ? '‚úÖ' : '‚ùå'}`);
        console.log(`   ‚îî‚îÄ Conex√£o estabelecida com sucesso!`);
    }
    
    /**
     * Cria um array plano de todos os soundfonts para acesso por √≠ndice
     */
    initializeFlatCatalog() {
        this.flatCatalog = [];
        
        if (!this.catalogManager || !this.catalogManager.fullCatalog) {
            console.error('‚ùå CatalogManager inv√°lido ou cat√°logo n√£o dispon√≠vel');
            return;
        }
        
        const catalog = this.catalogManager.fullCatalog;
        
        // Iterar por todas as categorias e subcategorias
        Object.entries(catalog).forEach(([categoryName, subcategories]) => {
            Object.entries(subcategories).forEach(([subcategoryName, variations]) => {
                variations.forEach((variation, variationIndex) => {
                    // üîß CORRE√á√ÉO: Extrair MIDI number real (0-127) do midiNumber string
                    // variation.midiNumber pode ser "0000", "0001", ..., "0127" (GM instruments)
                    // ou valores maiores como "1260" (apenas identificador de arquivo)
                    let realMidiNumber = null;
                    const rawMidiNumber = variation.midiNumber;
                    
                    if (rawMidiNumber !== undefined && rawMidiNumber !== null) {
                        const numericValue = parseInt(rawMidiNumber, 10);
                        
                        // Se estiver no range MIDI v√°lido (0-127), usar como MIDI number real
                        if (Number.isFinite(numericValue) && numericValue >= 0 && numericValue <= 127) {
                            realMidiNumber = numericValue;
                        } else if (Number.isFinite(numericValue)) {
                            // Se for maior que 127, √© apenas identificador de arquivo
                            // Tentar mapear via GM note se dispon√≠vel
                            realMidiNumber = variation.gmNote !== undefined 
                                ? parseInt(variation.gmNote, 10)
                                : null;
                        }
                    }
                    
                    this.flatCatalog.push({
                        index: this.flatCatalog.length + 1, // 1-based index
                        category: categoryName,
                        subcategory: subcategoryName,
                        variation: variation,
                        variationIndex: variationIndex,
                        // Informa√ß√µes do soundfont
                        midiNumber: realMidiNumber, // MIDI number real (0-127 ou null)
                        fileNumber: rawMidiNumber,  // N√∫mero do arquivo (pode ser > 127)
                        soundfont: variation.soundfont,
                        url: variation.url
                    });
                });
            });
        });
        
        this.totalSoundfonts = this.flatCatalog.length;
        
        if (this.totalSoundfonts === 0) {
            console.error('‚ùå Cat√°logo plano est√° vazio!');
            return;
        }
        
        // üîç An√°lise de midiNumbers
        const withValidMidi = this.flatCatalog.filter(sf => Number.isFinite(sf.midiNumber) && sf.midiNumber >= 0 && sf.midiNumber <= 127);
        const withoutMidi = this.flatCatalog.filter(sf => !Number.isFinite(sf.midiNumber));
        const withFileNumberOnly = this.flatCatalog.filter(sf => !Number.isFinite(sf.midiNumber) && sf.fileNumber);
        
        console.log(`‚úÖ Cat√°logo linearizado com ${this.totalSoundfonts} soundfonts`);
        console.log(`   ‚îú‚îÄ Com MIDI number v√°lido (0-127): ${withValidMidi.length}`);
        console.log(`   ‚îú‚îÄ Sem MIDI number (s√≥ fileNumber): ${withFileNumberOnly.length}`);
        console.log(`   ‚îî‚îÄ Sem identifica√ß√£o num√©rica: ${withoutMidi.length - withFileNumberOnly.length}`);
        
        // Log das primeiras e √∫ltimas entradas para valida√ß√£o
        if (this.totalSoundfonts > 0) {
            const first = this.flatCatalog[0];
            const last = this.flatCatalog[this.totalSoundfonts - 1];
            
            console.log(`   ‚îú‚îÄ Primeiro: [${first.index}] ${first.category} ‚Üí ${first.subcategory} ‚Üí ${first.soundfont}`);
            console.log(`   ‚îÇ  ‚îî‚îÄ MIDI: ${first.midiNumber ?? 'N/A'}, File: ${first.fileNumber ?? 'N/A'}`);
            console.log(`   ‚îî‚îÄ √öltimo: [${last.index}] ${last.category} ‚Üí ${last.subcategory} ‚Üí ${last.soundfont}`);
            console.log(`      ‚îî‚îÄ MIDI: ${last.midiNumber ?? 'N/A'}, File: ${last.fileNumber ?? 'N/A'}`);
        }
        
        // Log de exemplos sem MIDI number
        if (withFileNumberOnly.length > 0) {
            const example = withFileNumberOnly[0];
            console.log(`   üìå Exemplo sem MIDI number: ${example.soundfont} (fileNumber: ${example.fileNumber})`);
        }
    }
    
    /**
     * Processa mensagem MIDI Program Change e determina dire√ß√£o de navega√ß√£o
     * @param {Object} message - Mensagem MIDI Program Change
     * @param {number} message.program - Valor do programa (0-127)
     * @param {number} message.channel - Canal MIDI (0-15)
     */
    handleProgramChange(message) {
        const { program, channel } = message;
        
        // Validar entrada
        if (!Number.isFinite(program) || program < 0 || program > 127) {
            console.warn(`‚ö†Ô∏è Valor de programa inv√°lido: ${program}`);
            return;
        }
        
        const channelIndex = Number.isFinite(channel) ? Math.max(0, Math.min(15, channel)) : 0;
        
        // Obter valor anterior do programa para este canal
        const previousProgram = this.channelState.get(channelIndex);
        
        // Se √© a primeira mensagem deste canal, apenas armazenar
        if (previousProgram === null) {
            this.channelState.set(channelIndex, program);
            console.log(`üéπ Canal ${channelIndex}: valor inicial de programa definido como ${program}`);
            return;
        }
        
        // Determinar dire√ß√£o de navega√ß√£o
        const direction = this.calculateDirection(previousProgram, program);
        
        // Atualizar estado do canal
        this.channelState.set(channelIndex, program);
        
        // Navegar no cat√°logo
        if (direction !== 0) {
            this.navigate(direction, channelIndex);
        }
        
        console.log(`üìä Canal ${channelIndex}: ${previousProgram} ‚Üí ${program} | Dire√ß√£o: ${direction > 0 ? '+1' : direction < 0 ? '-1' : '0'}`);
    }
    
    /**
     * Calcula a dire√ß√£o de navega√ß√£o baseado em dois valores consecutivos
     * @param {number} previous - Valor anterior (0-127)
     * @param {number} current - Valor atual (0-127)
     * @returns {number} +1 para incremento, -1 para decremento, 0 para sem mudan√ßa
     */
    calculateDirection(previous, current) {
        // Sem mudan√ßa
        if (previous === current) {
            return 0;
        }
        
        // Exce√ß√£o 1: 127 ‚Üí 0 = incremento (wrap-around para frente)
        if (previous === 127 && current === 0) {
            return +1;
        }
        
        // Exce√ß√£o 2: 0 ‚Üí 127 = decremento (wrap-around para tr√°s)
        if (previous === 0 && current === 127) {
            return -1;
        }
        
        // Caso normal: compara√ß√£o simples
        if (current > previous) {
            return +1; // Incremento
        } else {
            return -1; // Decremento
        }
    }
    
    /**
     * Navega pelo cat√°logo
     * @param {number} direction - +1 para avan√ßar, -1 para retroceder
     * @param {number} channel - Canal MIDI que originou o comando
     */
    navigate(direction, channel = 0) {
        if (this.totalSoundfonts === 0) {
            console.warn('‚ö†Ô∏è Cat√°logo vazio, navega√ß√£o imposs√≠vel');
            return;
        }
        
        const previousIndex = this.currentIndex;
        
        // Aplicar dire√ß√£o com wrap-around circular
        if (direction > 0) {
            // Incremento: 811 ‚Üí 1
            this.currentIndex = this.currentIndex >= this.totalSoundfonts ? 1 : this.currentIndex + 1;
        } else if (direction < 0) {
            // Decremento: 1 ‚Üí 811
            this.currentIndex = this.currentIndex <= 1 ? this.totalSoundfonts : this.currentIndex - 1;
        }
        
        // Obter soundfont atual
        const currentSoundfont = this.getSoundfontAtIndex(this.currentIndex);
        
        if (!currentSoundfont) {
            console.error(`‚ùå Soundfont n√£o encontrado no √≠ndice ${this.currentIndex}`);
            return;
        }
        
        // Log detalhado da transi√ß√£o
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log(`üéº NAVEGA√á√ÉO NO CAT√ÅLOGO | Canal ${channel}`);
        console.log(`   ‚îú‚îÄ Dire√ß√£o: ${direction > 0 ? '‚û°Ô∏è +1 (Incremento)' : '‚¨ÖÔ∏è -1 (Decremento)'}`);
        console.log(`   ‚îú‚îÄ √çndice: ${previousIndex} ‚Üí ${this.currentIndex} / ${this.totalSoundfonts}`);
        console.log(`   ‚îú‚îÄ Categoria: ${currentSoundfont.category}`);
        console.log(`   ‚îú‚îÄ Subcategoria: ${currentSoundfont.subcategory}`);
        console.log(`   ‚îú‚îÄ Soundfont: ${currentSoundfont.soundfont}`);
        console.log(`   ‚îú‚îÄ MIDI Number: ${currentSoundfont.midiNumber}`);
        console.log(`   ‚îî‚îÄ URL: ${currentSoundfont.url}`);
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // Callback de mudan√ßa de √≠ndice
        if (this.onIndexChange) {
            try {
                this.onIndexChange(this.currentIndex, currentSoundfont);
            } catch (error) {
                console.error('‚ùå Erro no callback onIndexChange:', error);
            }
        }
        
        // üîç LOG DIAGN√ìSTICO: Estado antes da atualiza√ß√£o visual
        console.log('üîç DEBUG: Estado antes de updateVisualSelector');
        console.log(`   ‚îú‚îÄ this.currentIndex: ${this.currentIndex}`);
        console.log(`   ‚îú‚îÄ direction: ${direction}`);
        console.log(`   ‚îú‚îÄ instrumentSelectorControls dispon√≠vel: ${!!this.instrumentSelectorControls}`);
        console.log(`   ‚îî‚îÄ navigateByDirection dispon√≠vel: ${typeof this.instrumentSelectorControls?.navigateByDirection}`);
        
        // Atualizar interface visual (passando dire√ß√£o para feedback dos bot√µes)
        this.updateVisualSelector(this.currentIndex, currentSoundfont, direction);
        
        // üîç LOG DIAGN√ìSTICO: Verificar elemento #instrument-select ap√≥s atualiza√ß√£o
        const selectElement = document.getElementById('instrument-select');
        if (selectElement) {
            console.log('üîç DEBUG: Estado de #instrument-select ap√≥s atualiza√ß√£o');
            console.log(`   ‚îú‚îÄ Op√ß√µes totais: ${selectElement.options.length}`);
            console.log(`   ‚îú‚îÄ selectedIndex: ${selectElement.selectedIndex}`);
            console.log(`   ‚îú‚îÄ value: ${selectElement.value}`);
            if (selectElement.selectedOptions[0]) {
                console.log(`   ‚îî‚îÄ Texto selecionado: ${selectElement.selectedOptions[0].textContent}`);
            }
        } else {
            console.error('‚ùå Elemento #instrument-select N√ÉO ENCONTRADO no DOM!');
        }
        
        // NOTA: loadAndPlaySoundfont n√£o √© mais chamado aqui porque
        // instrumentSelectorControls.navigateByDirection j√° carrega o soundfont
        // automaticamente atrav√©s do stepInstrument
        // Se instrumentSelectorControls n√£o estiver dispon√≠vel, o fallback ser√° usado
        
        // Verificar se precisa usar fallback de carregamento direto
        if (!this.instrumentSelectorControls) {
            console.log('‚ö†Ô∏è Usando fallback de carregamento direto (InstrumentSelector n√£o conectado)');
            this.loadAndPlaySoundfont(currentSoundfont);
        }
    }
    
    /**
     * Obt√©m soundfont no √≠ndice especificado (1-based)
     * @param {number} index - √çndice (1 a totalSoundfonts)
     * @returns {Object|null} Soundfont ou null se inv√°lido
     */
    getSoundfontAtIndex(index) {
        if (index < 1 || index > this.totalSoundfonts) {
            return null;
        }
        
        // Array √© 0-based, √≠ndice √© 1-based
        return this.flatCatalog[index - 1];
    }
    
    /**
     * Atualiza interface visual do seletor de instrumentos
     * @param {number} index - √çndice atual
     * @param {Object} soundfont - Dados do soundfont
     * @param {number} direction - Dire√ß√£o da navega√ß√£o (+1 ou -1)
     */
    updateVisualSelector(index, soundfont, direction = 0) {
        let navigationSuccess = false;
        
        // PRIORIDADE 1: Acionar bot√£o visual correspondente (spin-up ou spin-down)
        console.log(`üéõÔ∏è updateVisualSelector: Tentando simular clique em bot√£o (dire√ß√£o: ${direction})`);
        
        if (this.instrumentSelectorControls && 
            typeof this.instrumentSelectorControls.navigateByDirection === 'function' &&
            direction !== 0) {
            try {
                console.log(`   ‚îî‚îÄ Chamando navigateByDirection(${direction})...`);
                const success = this.instrumentSelectorControls.navigateByDirection(direction);
                
                if (success) {
                    navigationSuccess = true;
                    if (direction > 0) {
                        console.log(`‚úÖ Bot√£o SPIN-DOWN (‚ñº) acionado visualmente via MIDI`);
                        console.log(`   ‚îú‚îÄ Simula√ß√£o de clique completa`);
                        console.log(`   ‚îú‚îÄ Efeito visual aplicado (pulse + glow)`);
                        console.log(`   ‚îú‚îÄ Evento click disparado`);
                        console.log(`   ‚îî‚îÄ Pr√≥ximo instrumento: [${index}/${this.totalSoundfonts}] ${soundfont.subcategory}`);
                    } else if (direction < 0) {
                        console.log(`‚úÖ Bot√£o SPIN-UP (‚ñ≤) acionado visualmente via MIDI`);
                        console.log(`   ‚îú‚îÄ Simula√ß√£o de clique completa`);
                        console.log(`   ‚îú‚îÄ Efeito visual aplicado (pulse + glow)`);
                        console.log(`   ‚îú‚îÄ Evento click disparado`);
                        console.log(`   ‚îî‚îÄ Instrumento anterior: [${index}/${this.totalSoundfonts}] ${soundfont.subcategory}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è navigateByDirection retornou false (dire√ß√£o: ${direction})`);
                    console.warn(`   ‚îî‚îÄ Poss√≠vel causa: bot√µes desabilitados ou carregamento em andamento`);
                }
            } catch (error) {
                console.error('‚ùå Erro ao acionar bot√£o de navega√ß√£o:', error);
            }
        } else if (direction === 0) {
            console.log('‚ÑπÔ∏è Navega√ß√£o inicial (sem dire√ß√£o) - bot√µes n√£o acionados');
        } else {
            console.warn('‚ö†Ô∏è InstrumentSelectorControls.navigateByDirection n√£o dispon√≠vel');
            console.warn(`   ‚îú‚îÄ instrumentSelectorControls existe: ${!!this.instrumentSelectorControls}`);
            console.warn(`   ‚îú‚îÄ navigateByDirection √© fun√ß√£o: ${typeof this.instrumentSelectorControls?.navigateByDirection}`);
            console.warn(`   ‚îî‚îÄ direction: ${direction}`);
        }
        
        // FALLBACK: Se navigateByDirection n√£o funcionou, usar selectInstrumentByIndex
        if (!navigationSuccess && this.instrumentSelectorControls && 
            typeof this.instrumentSelectorControls.selectInstrumentByIndex === 'function') {
            try {
                console.log(`üîÑ Usando fallback selectInstrumentByIndex para √≠ndice ${index}`);
                const entry = this.instrumentSelectorControls.selectInstrumentByIndex(index);
                
                if (entry) {
                    console.log(`‚úÖ #instrument-select atualizado via fallback: [${index}/${this.totalSoundfonts}] ${entry.subcategory}`);
                    navigationSuccess = true;
                } else {
                    console.warn(`‚ö†Ô∏è selectInstrumentByIndex retornou null para √≠ndice ${index}`);
                }
            } catch (error) {
                console.error('‚ùå Erro ao atualizar #instrument-select via fallback:', error);
            }
        }
        
        // ‚úÖ CORRE√á√ÉO: For√ßar sincroniza√ß√£o visual ap√≥s navega√ß√£o
        if (navigationSuccess && this.instrumentSelectorControls && 
            typeof this.instrumentSelectorControls.forceSyncVisualSelect === 'function') {
            try {
                console.log('üîÑ For√ßando sincroniza√ß√£o visual do select ap√≥s navega√ß√£o MIDI...');
                this.instrumentSelectorControls.forceSyncVisualSelect();
            } catch (error) {
                console.warn('‚ö†Ô∏è Erro ao for√ßar sincroniza√ß√£o visual:', error);
            }
        }
        
        // LEGADO: Atualizar seletor via highlightInstrument (fallback secund√°rio)
        if (window.instrumentSelector && typeof window.instrumentSelector.highlightInstrument === 'function') {
            try {
                window.instrumentSelector.highlightInstrument({
                    category: soundfont.category,
                    subcategory: soundfont.subcategory,
                    variationIndex: soundfont.variationIndex
                });
                console.log(`‚úÖ Interface legacy atualizada para √≠ndice ${index}`);
            } catch (error) {
                console.warn('‚ö†Ô∏è Erro ao atualizar seletor visual legacy:', error);
            }
        }
        
        // Atualizar UI customizada se existir
        this.updateCustomUI(index, soundfont);
    }
    
    /**
     * Atualiza elementos UI customizados
     * @param {number} index - √çndice atual
     * @param {Object} soundfont - Dados do soundfont
     */
    updateCustomUI(index, soundfont) {
        // Atualizar indicador de √≠ndice
        const indexDisplay = document.getElementById('catalog-index-display');
        if (indexDisplay) {
            indexDisplay.textContent = `${index} / ${this.totalSoundfonts}`;
        }
        
        // Atualizar nome do soundfont
        const nameDisplay = document.getElementById('catalog-soundfont-name');
        if (nameDisplay) {
            nameDisplay.textContent = soundfont.soundfont;
        }
        
        // Atualizar categoria
        const categoryDisplay = document.getElementById('catalog-category-name');
        if (categoryDisplay) {
            categoryDisplay.textContent = `${soundfont.category} ‚Üí ${soundfont.subcategory}`;
        }
        
        // Atualizar barra de progresso
        const progressBar = document.getElementById('catalog-progress-bar');
        if (progressBar) {
            const percentage = (index / this.totalSoundfonts) * 100;
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', index);
        }
    }
    
    /**
     * Carrega e toca o soundfont selecionado
     * @param {Object} soundfont - Dados do soundfont
     */
    loadAndPlaySoundfont(soundfont) {
        if (!this.soundfontManager) {
            console.warn('‚ö†Ô∏è SoundfontManager n√£o dispon√≠vel');
            return;
        }
        
        try {
            // üîß CORRE√á√ÉO: Usar midiNumber real (0-127) se dispon√≠vel
            const midiNum = soundfont.midiNumber; // J√° validado e convertido em initializeFlatCatalog
            
            // Tentar carregar via MIDI number se estiver no range v√°lido
            if (Number.isFinite(midiNum) && midiNum >= 0 && midiNum <= 127) {
                console.log(`üéº Carregando via MIDI number ${midiNum}: ${soundfont.soundfont}`);
                
                this.soundfontManager.loadInstrument(midiNum, {
                    setCurrent: true,
                    clearKit: false
                }).then(() => {
                    console.log(`‚úÖ Soundfont ${soundfont.soundfont} carregado (MIDI ${midiNum})`);
                    
                    // Tocar nota de preview (D√≥ central - C4)
                    this.playPreviewNote();
                    
                    // Callback de carregamento
                    if (this.onSoundfontLoad) {
                        this.onSoundfontLoad(soundfont, this.currentIndex);
                    }
                }).catch(error => {
                    console.error(`‚ùå Erro ao carregar soundfont ${soundfont.soundfont}:`, error);
                    // Fallback: tentar carregar via objeto variation
                    this.loadSoundfontFallback(soundfont);
                });
            } else {
                // MIDI number n√£o dispon√≠vel ou inv√°lido - usar fallback direto
                console.log(`‚ö†Ô∏è MIDI number ausente/inv√°lido para ${soundfont.soundfont} (fileNumber: ${soundfont.fileNumber})`);
                console.log(`   ‚îî‚îÄ Usando fallback via variation object`);
                this.loadSoundfontFallback(soundfont);
            }
        } catch (error) {
            console.error('‚ùå Erro ao processar carregamento de soundfont:', error);
        }
    }
    
    /**
     * M√©todo de fallback para carregar soundfont quando midiNumber √© inv√°lido
     * @param {Object} soundfont - Dados do soundfont
     */
    loadSoundfontFallback(soundfont) {
        if (!soundfont.variation) {
            console.error(`‚ùå N√£o foi poss√≠vel carregar ${soundfont.soundfont} - variation n√£o dispon√≠vel`);
            return;
        }
        
        try {
            this.soundfontManager.loadFromCatalog(soundfont.variation)
                .then(() => {
                    console.log(`‚úÖ Soundfont ${soundfont.soundfont} carregado via fallback`);
                    
                    // Tocar nota de preview
                    this.playPreviewNote();
                    
                    // Callback de carregamento
                    if (this.onSoundfontLoad) {
                        this.onSoundfontLoad(soundfont, this.currentIndex);
                    }
                }).catch(error => {
                    console.error(`‚ùå Erro ao carregar soundfont ${soundfont.soundfont} via fallback:`, error);
                });
        } catch (error) {
            console.error('‚ùå Erro ao processar fallback:', error);
        }
    }
    
    /**
     * Toca nota de preview do instrumento atual
     */
    playPreviewNote() {
        if (!this.soundfontManager) return;
        
        try {
            // Tocar C4 (D√≥ central) com velocity m√©dia
            const noteName = 'C4';
            const velocity = 0.7;
            const duration = 1000; // 1 segundo
            
            // Iniciar nota
            const noteId = this.soundfontManager.startSustainedNote(noteName, velocity);
            
            // Parar nota ap√≥s dura√ß√£o
            setTimeout(() => {
                if (noteId) {
                    this.soundfontManager.stopSustainedNote(noteId);
                }
            }, duration);
            
            console.log(`üéµ Preview: ${noteName} tocado`);
        } catch (error) {
            console.warn('‚ö†Ô∏è Erro ao tocar nota de preview:', error);
        }
    }
    
    /**
     * Navega para √≠ndice espec√≠fico
     * @param {number} index - √çndice desejado (1-based)
     * @returns {boolean} Sucesso da navega√ß√£o
     */
    goToIndex(index) {
        if (index < 1 || index > this.totalSoundfonts) {
            console.warn(`‚ö†Ô∏è √çndice ${index} fora da faixa v√°lida (1-${this.totalSoundfonts})`);
            return false;
        }
        
        this.currentIndex = index;
        const soundfont = this.getSoundfontAtIndex(index);
        
        if (!soundfont) {
            return false;
        }
        
        console.log(`üéØ Navega√ß√£o direta para √≠ndice ${index}`);
        
        // Atualizar interface e carregar soundfont
        this.updateVisualSelector(index, soundfont);
        this.loadAndPlaySoundfont(soundfont);
        
        if (this.onIndexChange) {
            this.onIndexChange(index, soundfont);
        }
        
        return true;
    }
    
    /**
     * Obt√©m estado atual da navega√ß√£o
     * @returns {Object} Estado atual
     */
    getState() {
        const currentSoundfont = this.getSoundfontAtIndex(this.currentIndex);
        
        return {
            currentIndex: this.currentIndex,
            totalSoundfonts: this.totalSoundfonts,
            currentSoundfont: currentSoundfont,
            channelStates: Array.from(this.channelState.entries()).map(([channel, program]) => ({
                channel,
                lastProgram: program
            })),
            progress: {
                percentage: (this.currentIndex / this.totalSoundfonts) * 100,
                remaining: this.totalSoundfonts - this.currentIndex
            }
        };
    }
    
    /**
     * Reseta estado de todos os canais
     */
    resetAllChannels() {
        for (let channel = 0; channel < 16; channel++) {
            this.channelState.set(channel, null);
        }
        console.log('üîÑ Estado de todos os canais resetado');
    }
    
    /**
     * Reseta navega√ß√£o para o in√≠cio
     */
    reset() {
        this.currentIndex = 1;
        this.resetAllChannels();
        console.log('üîÑ Navega√ß√£o resetada para √≠ndice 1');
    }
}

// Exportar para uso global
if (typeof window !== 'undefined') {
    window.CatalogNavigationManager = CatalogNavigationManager;
}
